(function(y,p){typeof exports=="object"&&typeof module<"u"?p(exports):typeof define=="function"&&define.amd?define(["exports"],p):(y=typeof globalThis<"u"?globalThis:y||self,p(y.MochimoWOTS={}))})(this,function(y){"use strict";var p=(n=>(n[n.BIG_ENDIAN=0]="BIG_ENDIAN",n[n.LITTLE_ENDIAN=1]="LITTLE_ENDIAN",n))(p||{});class I{constructor(t){this.buf=new Uint8Array(t),this.pos=0,this.byteOrder=0}static allocate(t){return new I(t)}static wrap(t){const e=new I(t.length);return e.buf.set(t),e}order(t){return this.byteOrder=t,this}position(t){if(t===void 0)return this.pos;if(t<0||t>this.buf.length)throw new Error("Invalid position, position: "+t+", length: "+this.buf.length);return this.pos=t,this}capacity(){return this.buf.length}put(t,e,s){if(typeof t=="number"){if(this.pos>=this.buf.length)throw new Error("Buffer overflow");return this.buf[this.pos++]=t&255,this}const r=e||0,i=s||t.length;if(r<0||r>t.length)throw new Error("Invalid offset");if(i<0||r+i>t.length)throw new Error("Invalid length");if(this.pos+i>this.buf.length)throw new Error("Buffer overflow");return this.buf.set(t.subarray(r,r+i),this.pos),this.pos+=i,this}putInt(t){if(this.pos+4>this.buf.length)throw new Error("Buffer overflow");return this.byteOrder===0?(this.buf[this.pos++]=t>>>24&255,this.buf[this.pos++]=t>>>16&255,this.buf[this.pos++]=t>>>8&255,this.buf[this.pos++]=t&255):(this.buf[this.pos++]=t&255,this.buf[this.pos++]=t>>>8&255,this.buf[this.pos++]=t>>>16&255,this.buf[this.pos++]=t>>>24&255),this}get(t){if(this.pos+t.length>this.buf.length)throw new Error("Buffer underflow");for(let e=0;e<t.length;e++)t[e]=this.buf[this.pos++];return this}get_(){if(this.pos>=this.buf.length)throw new Error("Buffer underflow");return this.buf[this.pos++]}array(){return new Uint8Array(this.buf)}rewind(){return this.pos=0,this}}const ht="0123456789abcdef";class l{static copyOf(t,e){const s=new Uint8Array(e);return s.set(t.slice(0,e)),s}static hexToBytes(t){let e=t.toLowerCase();e.startsWith("0x")&&(e=e.slice(2)),e.length%2!==0&&(e="0"+e);const s=new Uint8Array(e.length/2);for(let r=0;r<e.length;r+=2)s[r/2]=parseInt(e.slice(r,r+2),16);return s}static compareBytes(t,e){if(t.length!==e.length)return!1;for(let s=0;s<t.length;s++)if(t[s]!==e[s])return!1;return!0}static readLittleEndianUnsigned(t,e=8){const s=new Uint8Array(e);t.get(s);let r=0n;for(let i=e-1;i>=0;i--)r=r<<8n|BigInt(s[i]);return r}static trimAddress(t){return`${t.substring(0,32)}...${t.substring(t.length-24)}`}static numberToLittleEndian(t,e){const s=new Uint8Array(e);let r=t;for(let i=0;i<e;i++)s[i]=r&255,r=r>>>8;return s}static bytesToLittleEndian(t){const e=new Uint8Array(t.length);for(let s=0;s<t.length;s++)e[s]=t[t.length-1-s];return e}static fit(t,e){if(typeof t=="string"){const i=BigInt(t),h=new Uint8Array(e);let o=i;for(let a=0;a<e;a++)h[a]=Number(o&0xffn),o>>=8n;return h}const s=new Uint8Array(e),r=Math.min(t.length,e);return s.set(t.subarray(0,r)),s}static bytesToHex(t,e=0,s=t.length){const r=new Array(s*2);for(let i=0;i<s;i++){const h=t[i+e]&255;r[i*2]=ht[h>>>4],r[i*2+1]=ht[h&15]}return r.join("")}static toBytes(t,e){const s=t.toString(16).padStart(e*2,"0");return l.hexToBytes(s)}static toLittleEndian(t,e=0,s=t.length){const r=new Uint8Array(s);r.set(t.slice(e,e+s));for(let i=0;i<r.length>>1;i++){const h=r[i];r[i]=r[r.length-i-1],r[r.length-i-1]=h}return r}static clear(t){t.fill(0)}static areEqual(t,e){if(t.length!==e.length)return!1;for(let s=0;s<t.length;s++)if(t[s]!==e[s])return!1;return!0}}function ot(n){if(!Number.isSafeInteger(n)||n<0)throw new Error("positive integer expected, got "+n)}function xt(n){return n instanceof Uint8Array||ArrayBuffer.isView(n)&&n.constructor.name==="Uint8Array"}function X(n,...t){if(!xt(n))throw new Error("Uint8Array expected");if(t.length>0&&!t.includes(n.length))throw new Error("Uint8Array expected of length "+t+", got length="+n.length)}function D(n,t=!0){if(n.destroyed)throw new Error("Hash instance has been destroyed");if(t&&n.finished)throw new Error("Hash#digest() has already been called")}function at(n,t){X(n);const e=t.outputLen;if(n.length<e)throw new Error("digestInto() expects output buffer of length at least "+e)}/*! noble-hashes - MIT License (c) 2022 Paul Miller (paulmillr.com) */const mt=n=>new Uint32Array(n.buffer,n.byteOffset,Math.floor(n.byteLength/4)),j=n=>new DataView(n.buffer,n.byteOffset,n.byteLength),L=(n,t)=>n<<32-t|n>>>t,R=(n,t)=>n<<t|n>>>32-t>>>0,dt=new Uint8Array(new Uint32Array([287454020]).buffer)[0]===68,Lt=n=>n<<24&4278190080|n<<8&16711680|n>>>8&65280|n>>>24&255;function lt(n){for(let t=0;t<n.length;t++)n[t]=Lt(n[t])}function Bt(n){if(typeof n!="string")throw new Error("utf8ToBytes expected string, got "+typeof n);return new Uint8Array(new TextEncoder().encode(n))}function q(n){return typeof n=="string"&&(n=Bt(n)),X(n),n}class ct{clone(){return this._cloneInto()}}function J(n){const t=s=>n().update(q(s)).digest(),e=n();return t.outputLen=e.outputLen,t.blockLen=e.blockLen,t.create=()=>n(),t}function Ut(n,t,e,s){if(typeof n.setBigUint64=="function")return n.setBigUint64(t,e,s);const r=BigInt(32),i=BigInt(4294967295),h=Number(e>>r&i),o=Number(e&i),a=s?4:0,d=s?0:4;n.setUint32(t+a,h,s),n.setUint32(t+d,o,s)}const Nt=(n,t,e)=>n&t^~n&e,Ht=(n,t,e)=>n&t^n&e^t&e;class ut extends ct{constructor(t,e,s,r){super(),this.blockLen=t,this.outputLen=e,this.padOffset=s,this.isLE=r,this.finished=!1,this.length=0,this.pos=0,this.destroyed=!1,this.buffer=new Uint8Array(t),this.view=j(this.buffer)}update(t){D(this);const{view:e,buffer:s,blockLen:r}=this;t=q(t);const i=t.length;for(let h=0;h<i;){const o=Math.min(r-this.pos,i-h);if(o===r){const a=j(t);for(;r<=i-h;h+=r)this.process(a,h);continue}s.set(t.subarray(h,h+o),this.pos),this.pos+=o,h+=o,this.pos===r&&(this.process(e,0),this.pos=0)}return this.length+=t.length,this.roundClean(),this}digestInto(t){D(this),at(t,this),this.finished=!0;const{buffer:e,view:s,blockLen:r,isLE:i}=this;let{pos:h}=this;e[h++]=128,this.buffer.subarray(h).fill(0),this.padOffset>r-h&&(this.process(s,0),h=0);for(let u=h;u<r;u++)e[u]=0;Ut(s,r-8,BigInt(this.length*8),i),this.process(s,0);const o=j(t),a=this.outputLen;if(a%4)throw new Error("_sha2: outputLen should be aligned to 32bit");const d=a/4,g=this.get();if(d>g.length)throw new Error("_sha2: outputLen bigger than state");for(let u=0;u<d;u++)o.setUint32(4*u,g[u],i)}digest(){const{buffer:t,outputLen:e}=this;this.digestInto(t);const s=t.slice(0,e);return this.destroy(),s}_cloneInto(t){t||(t=new this.constructor),t.set(...this.get());const{blockLen:e,buffer:s,length:r,finished:i,destroyed:h,pos:o}=this;return t.length=r,t.pos=o,t.finished=i,t.destroyed=h,r%e&&t.buffer.set(s),t}}const _t=new Uint32Array([1116352408,1899447441,3049323471,3921009573,961987163,1508970993,2453635748,2870763221,3624381080,310598401,607225278,1426881987,1925078388,2162078206,2614888103,3248222580,3835390401,4022224774,264347078,604807628,770255983,1249150122,1555081692,1996064986,2554220882,2821834349,2952996808,3210313671,3336571891,3584528711,113926993,338241895,666307205,773529912,1294757372,1396182291,1695183700,1986661051,2177026350,2456956037,2730485921,2820302411,3259730800,3345764771,3516065817,3600352804,4094571909,275423344,430227734,506948616,659060556,883997877,958139571,1322822218,1537002063,1747873779,1955562222,2024104815,2227730452,2361852424,2428436474,2756734187,3204031479,3329325298]),U=new Uint32Array([1779033703,3144134277,1013904242,2773480762,1359893119,2600822924,528734635,1541459225]),N=new Uint32Array(64);class Gt extends ut{constructor(){super(64,32,8,!1),this.A=U[0]|0,this.B=U[1]|0,this.C=U[2]|0,this.D=U[3]|0,this.E=U[4]|0,this.F=U[5]|0,this.G=U[6]|0,this.H=U[7]|0}get(){const{A:t,B:e,C:s,D:r,E:i,F:h,G:o,H:a}=this;return[t,e,s,r,i,h,o,a]}set(t,e,s,r,i,h,o,a){this.A=t|0,this.B=e|0,this.C=s|0,this.D=r|0,this.E=i|0,this.F=h|0,this.G=o|0,this.H=a|0}process(t,e){for(let u=0;u<16;u++,e+=4)N[u]=t.getUint32(e,!1);for(let u=16;u<64;u++){const w=N[u-15],f=N[u-2],k=L(w,7)^L(w,18)^w>>>3,G=L(f,17)^L(f,19)^f>>>10;N[u]=G+N[u-7]+k+N[u-16]|0}let{A:s,B:r,C:i,D:h,E:o,F:a,G:d,H:g}=this;for(let u=0;u<64;u++){const w=L(o,6)^L(o,11)^L(o,25),f=g+w+Nt(o,a,d)+_t[u]+N[u]|0,G=(L(s,2)^L(s,13)^L(s,22))+Ht(s,r,i)|0;g=d,d=a,a=o,o=h+f|0,h=i,i=r,r=s,s=f+G|0}s=s+this.A|0,r=r+this.B|0,i=i+this.C|0,h=h+this.D|0,o=o+this.E|0,a=a+this.F|0,d=d+this.G|0,g=g+this.H|0,this.set(s,r,i,h,o,a,d,g)}roundClean(){N.fill(0)}destroy(){this.set(0,0,0,0,0,0,0,0),this.buffer.fill(0)}}const vt=J(()=>new Gt),P=BigInt(2**32-1),ft=BigInt(32);function kt(n,t=!1){return t?{h:Number(n&P),l:Number(n>>ft&P)}:{h:Number(n>>ft&P)|0,l:Number(n&P)|0}}function Wt(n,t=!1){let e=new Uint32Array(n.length),s=new Uint32Array(n.length);for(let r=0;r<n.length;r++){const{h:i,l:h}=kt(n[r],t);[e[r],s[r]]=[i,h]}return[e,s]}const Ft=(n,t,e)=>n<<e|t>>>32-e,Ot=(n,t,e)=>t<<e|n>>>32-e,Ct=(n,t,e)=>t<<e-32|n>>>64-e,Dt=(n,t,e)=>n<<e-32|t>>>64-e,gt=[],wt=[],At=[],Rt=BigInt(0),W=BigInt(1),Pt=BigInt(2),Mt=BigInt(7),Yt=BigInt(256),Vt=BigInt(113);for(let n=0,t=W,e=1,s=0;n<24;n++){[e,s]=[s,(2*e+3*s)%5],gt.push(2*(5*s+e)),wt.push((n+1)*(n+2)/2%64);let r=Rt;for(let i=0;i<7;i++)t=(t<<W^(t>>Mt)*Vt)%Yt,t&Pt&&(r^=W<<(W<<BigInt(i))-W);At.push(r)}const[$t,Kt]=Wt(At,!0),bt=(n,t,e)=>e>32?Ct(n,t,e):Ft(n,t,e),Tt=(n,t,e)=>e>32?Dt(n,t,e):Ot(n,t,e);function Xt(n,t=24){const e=new Uint32Array(10);for(let s=24-t;s<24;s++){for(let h=0;h<10;h++)e[h]=n[h]^n[h+10]^n[h+20]^n[h+30]^n[h+40];for(let h=0;h<10;h+=2){const o=(h+8)%10,a=(h+2)%10,d=e[a],g=e[a+1],u=bt(d,g,1)^e[o],w=Tt(d,g,1)^e[o+1];for(let f=0;f<50;f+=10)n[h+f]^=u,n[h+f+1]^=w}let r=n[2],i=n[3];for(let h=0;h<24;h++){const o=wt[h],a=bt(r,i,o),d=Tt(r,i,o),g=gt[h];r=n[g],i=n[g+1],n[g]=a,n[g+1]=d}for(let h=0;h<50;h+=10){for(let o=0;o<10;o++)e[o]=n[h+o];for(let o=0;o<10;o++)n[h+o]^=~e[(o+2)%10]&e[(o+4)%10]}n[0]^=$t[s],n[1]^=Kt[s]}e.fill(0)}class z extends ct{constructor(t,e,s,r=!1,i=24){if(super(),this.blockLen=t,this.suffix=e,this.outputLen=s,this.enableXOF=r,this.rounds=i,this.pos=0,this.posOut=0,this.finished=!1,this.destroyed=!1,ot(s),0>=this.blockLen||this.blockLen>=200)throw new Error("Sha3 supports only keccak-f1600 function");this.state=new Uint8Array(200),this.state32=mt(this.state)}keccak(){dt||lt(this.state32),Xt(this.state32,this.rounds),dt||lt(this.state32),this.posOut=0,this.pos=0}update(t){D(this);const{blockLen:e,state:s}=this;t=q(t);const r=t.length;for(let i=0;i<r;){const h=Math.min(e-this.pos,r-i);for(let o=0;o<h;o++)s[this.pos++]^=t[i++];this.pos===e&&this.keccak()}return this}finish(){if(this.finished)return;this.finished=!0;const{state:t,suffix:e,pos:s,blockLen:r}=this;t[s]^=e,e&128&&s===r-1&&this.keccak(),t[r-1]^=128,this.keccak()}writeInto(t){D(this,!1),X(t),this.finish();const e=this.state,{blockLen:s}=this;for(let r=0,i=t.length;r<i;){this.posOut>=s&&this.keccak();const h=Math.min(s-this.posOut,i-r);t.set(e.subarray(this.posOut,this.posOut+h),r),this.posOut+=h,r+=h}return t}xofInto(t){if(!this.enableXOF)throw new Error("XOF is not possible for this instance");return this.writeInto(t)}xof(t){return ot(t),this.xofInto(new Uint8Array(t))}digestInto(t){if(at(t,this),this.finished)throw new Error("digest() was already called");return this.writeInto(t),this.destroy(),t}digest(){return this.digestInto(new Uint8Array(this.outputLen))}destroy(){this.destroyed=!0,this.state.fill(0)}_cloneInto(t){const{blockLen:e,suffix:s,outputLen:r,rounds:i,enableXOF:h}=this;return t||(t=new z(e,s,r,h,i)),t.state32.set(this.state32),t.pos=this.pos,t.posOut=this.posOut,t.finished=this.finished,t.rounds=i,t.suffix=s,t.outputLen=r,t.enableXOF=h,t.destroyed=this.destroyed,t}}const jt=((n,t,e)=>J(()=>new z(t,n,e)))(6,72,512/8),qt=new Uint8Array([7,4,13,1,10,6,15,3,12,0,9,5,2,14,11,8]),Et=new Uint8Array(new Array(16).fill(0).map((n,t)=>t)),Jt=Et.map(n=>(9*n+5)%16);let Z=[Et],Q=[Jt];for(let n=0;n<4;n++)for(let t of[Z,Q])t.push(t[n].map(e=>qt[e]));const yt=[[11,14,15,12,5,8,7,9,11,13,14,15,6,7,9,8],[12,13,11,15,6,9,9,7,12,15,11,13,7,8,7,7],[13,15,14,11,7,7,6,8,13,14,13,12,5,5,6,9],[14,11,12,14,8,6,5,5,15,12,15,14,9,9,8,6],[15,12,13,13,9,5,8,6,14,11,12,11,8,6,5,5]].map(n=>new Uint8Array(n)),zt=Z.map((n,t)=>n.map(e=>yt[t][e])),Zt=Q.map((n,t)=>n.map(e=>yt[t][e])),Qt=new Uint32Array([0,1518500249,1859775393,2400959708,2840853838]),te=new Uint32Array([1352829926,1548603684,1836072691,2053994217,0]);function pt(n,t,e,s){return n===0?t^e^s:n===1?t&e|~t&s:n===2?(t|~e)^s:n===3?t&s|e&~s:t^(e|~s)}const M=new Uint32Array(16);class ee extends ut{constructor(){super(64,20,8,!0),this.h0=1732584193,this.h1=-271733879,this.h2=-1732584194,this.h3=271733878,this.h4=-1009589776}get(){const{h0:t,h1:e,h2:s,h3:r,h4:i}=this;return[t,e,s,r,i]}set(t,e,s,r,i){this.h0=t|0,this.h1=e|0,this.h2=s|0,this.h3=r|0,this.h4=i|0}process(t,e){for(let f=0;f<16;f++,e+=4)M[f]=t.getUint32(e,!0);let s=this.h0|0,r=s,i=this.h1|0,h=i,o=this.h2|0,a=o,d=this.h3|0,g=d,u=this.h4|0,w=u;for(let f=0;f<5;f++){const k=4-f,G=Qt[f],rt=te[f],C=Z[f],nt=Q[f],m=zt[f],he=Zt[f];for(let B=0;B<16;B++){const it=R(s+pt(f,i,o,d)+M[C[B]]+G,m[B])+u|0;s=u,u=d,d=R(o,10)|0,o=i,i=it}for(let B=0;B<16;B++){const it=R(r+pt(k,h,a,g)+M[nt[B]]+rt,he[B])+w|0;r=w,w=g,g=R(a,10)|0,a=h,h=it}}this.set(this.h1+o+g|0,this.h2+d+w|0,this.h3+u+r|0,this.h4+s+h|0,this.h0+i+a|0)}roundClean(){M.fill(0)}destroy(){this.destroyed=!0,this.buffer.fill(0),this.set(0,0,0,0,0)}}const se=J(()=>new ee);class T{constructor(t="sha256"){this.algorithm=t,this.hasher=this.createHasher(t)}createHasher(t){switch(t.toLowerCase()){case"sha256":return vt.create();case"sha3-512":return jt.create();case"ripemd160":return se.create();default:throw new Error(`Unsupported hash algorithm: ${t}`)}}update(t,e=0,s=t.length){if(e<0||e>t.length)throw new Error("Invalid offset");if(s<0||e+s>t.length)throw new Error("Invalid length");const r=t.subarray(e,e+s);this.hasher.update(r)}digest(){const t=this.hasher.digest();return this.hasher=this.createHasher(this.algorithm),t}static hash(t,e,s){const r=new T;return e!==void 0&&s!==void 0?r.update(new Uint8Array(t.subarray(e,e+s))):r.update(new Uint8Array(t)),r.digest()}static hashWith(t,e){const s=new T(t);return s.update(e),s.digest()}}const K=class K{static setChainAddr(t,e){t.position(20),t.putInt(e)}static setHashAddr(t,e){t.position(24),t.putInt(e)}static setKeyAndMask(t,e){t.position(28),t.putInt(e)}static addrToBytes(t){t.position(0);const e=new Uint8Array(t.capacity());for(let s=0;s<e.length;s+=4){const r=t.get_(),i=t.get_(),h=t.get_(),o=t.get_();e[s]=o,e[s+1]=h,e[s+2]=i,e[s+3]=r}return e}static prf(t,e,s,r){const i=new Uint8Array(96),h=new Uint8Array(32);h[31]=this.XMSS_HASH_PADDING_PRF,i.set(h,0),i.set(r,32),i.set(s,64);const o=new T;o.update(i);const a=o.digest();return t.set(a,e),t}static thashF(t,e,s,r,i,h){const o=new Uint8Array(96),a=new Uint8Array(32);a[31]=this.XMSS_HASH_PADDING_F,o.set(a,0),this.setKeyAndMask(h,0);let d=this.addrToBytes(h);this.prf(o,32,d,i),this.setKeyAndMask(h,1),d=this.addrToBytes(h);const g=new Uint8Array(32);this.prf(g,0,d,i);for(let f=0;f<32;f++)o[64+f]=s[f+r]^g[f];const u=new T;u.update(o);const w=u.digest();t.set(w,e)}};K.XMSS_HASH_PADDING_F=0,K.XMSS_HASH_PADDING_PRF=3;let H=K;const _=class _{static getTag(t){if(t.length!==2208)throw new Error("Invalid address length");const e=new Uint8Array(_.TAG_LENGTH);return e.set(t.subarray(t.length-_.TAG_LENGTH)),e}static isZero(t){return!t||t.length!==_.TAG_LENGTH?!1:t.every(e=>e===0)}static isValid(t){return!(!t||t.length!==_.TAG_LENGTH)}static tag(t,e){if(!this.isValid(e))throw new Error("Invalid tag");if(t.length!==2208)throw new Error("Invalid address length");if(e.length!==12)throw new Error("Invalid tag length");const s=new Uint8Array(t);return s.set(e,s.length-e.length),s}};_.TAG_LENGTH=12;let F=_;const b=class b{static gen_chain(t,e,s,r,i,h,o,a){t.set(s.subarray(r,r+b.PARAMSN),e);for(let d=i;d<i+h&&d<16;d++)H.setHashAddr(a,d),H.thashF(t,e,t,e,o,a)}static expand_seed(t,e){for(let s=0;s<b.WOTSLEN;s++){const r=l.toBytes(s,32);H.prf(t,s*32,r,e)}}static base_w(t,e){return this.base_w_(t,e,0,e.length)}static base_w_(t,e,s=0,r=e.length){let i=0,h=0,o=0,a=0;for(let d=0;d<r;d++)a===0&&(o=t[i++],a+=8),a-=4,e[h+++s]=o>>a&15;return e}static wotsChecksum(t,e){let s=0;for(let i=0;i<64;i++)s+=15-t[i];s<<=4;const r=new Uint8Array(2);return r[0]=s>>8&255,r[1]=s&255,this.base_w_(r,t,e,t.length-e)}static chain_lengths(t,e){const s=this.base_w_(t,e,0,64);return this.wotsChecksum(s,64)}static wots_pkgen(t,e,s,r,i){this.expand_seed(t,e);const h=I.wrap(i);h.order(p.LITTLE_ENDIAN);for(let o=0;o<b.WOTSLEN;o++)H.setChainAddr(h,o),this.gen_chain(t,o*32,t,o*32,0,15,s.subarray(r),h)}static wots_sign(t,e,s,r,i,h){const o=new Array(b.WOTSLEN);this.chain_lengths(e,o),this.expand_seed(t,s);const a=I.wrap(h);a.order(p.LITTLE_ENDIAN);for(let d=0;d<b.WOTSLEN;d++)H.setChainAddr(a,d),this.gen_chain(t,d*32,t,d*32,0,o[d],r.subarray(i),a)}static wots_pk_from_sig(t,e,s,r){const i=new Uint8Array(b.WOTSSIGBYTES),h=new Array(b.WOTSLEN),o=new Uint8Array(r),a=I.wrap(o);a.order(p.LITTLE_ENDIAN),this.chain_lengths(e,h);for(let d=0;d<b.WOTSLEN;d++)H.setChainAddr(a,d),this.gen_chain(i,d*32,t,d*32,h[d],15-h[d],s,a);return i}static generateAddress(t,e,s){if(!s)throw new Error("Invalid componentsGenerator");if(e.length!==32)throw new Error("Invalid secret length");if(t!==null&&t.length!==12)throw new Error("Invalid tag");const r=new Uint8Array(2144),i=s(e);b.wots_pkgen(r,i.private_seed,i.public_seed,0,i.addr_seed);const h=new Uint8Array(2208);h.set(r,0),h.set(i.public_seed,2144),h.set(i.addr_seed,2176);const o=t?F.tag(h,t):h;for(let a=0;a<10;a++)if(!this.isValid(i.private_seed,o,Y))throw new Error("Invalid WOTS");return o}static isValidWithComponents(t,e,s,r,i){if(t.length!==32)throw new Error("Invalid secret length");if(e.length!==2144)throw new Error("Invalid pk length");if(s.length!==32)throw new Error("Invalid pubSeed length");if(r.length!==32)throw new Error("Invalid rnd2 length");const h=new Uint8Array(32);i(h);const o=new Uint8Array(2144);this.wots_sign(o,h,t,s,0,r);const a=this.wots_pk_from_sig(o,h,s,r);return l.compareBytes(a,e)}static splitAddress(t,e,s,r,i){if(t.length!==2208)throw new Error("Invalid address length");if(e.length!==2144)throw new Error("Invalid pk length");if(s.length!==32)throw new Error("Invalid pubSeed length");if(r.length!==32)throw new Error("Invalid rnd2 length");if(i!==null&&i.length!==12)throw new Error("Invalid tag length");e.set(t.subarray(0,2144)),s.set(t.subarray(2144,2176)),r.set(t.subarray(2176,2208)),i!==null&&i.set(r.subarray(20,32))}static isValid(t,e,s=Y){const r=new Uint8Array(2144),i=new Uint8Array(32),h=new Uint8Array(32);return this.splitAddress(e,r,i,h,null),this.isValidWithComponents(t,r,i,h,Y)}static generateRandomAddress(t,e,s=Y){if(e.length!==32)throw new Error("Invalid secret length");if(t!==null&&t.length!==12)throw new Error("Invalid tag");const r=new Uint8Array(2208),i=new Uint8Array(32);s(r),i.set(r.subarray(2176,2208)),this.wots_pkgen(r,e,r,2144,i),r.set(i,2176);const h=t?F.tag(r,t):r;for(let o=0;o<10;o++)if(!this.isValid(e,h,s))throw new Error("Invalid WOTS");return h}};b.WOTSW=16,b.WOTSLOGW=4,b.PARAMSN=32,b.WOTSLEN1=64,b.WOTSLEN2=3,b.WOTSLEN=67,b.WOTSSIGBYTES=2144,b.TXSIGLEN=2144;let c=b;function Y(n){for(let t=0;t<n.length;t++)n[t]=Math.floor(Math.random()*256)}const x=40,S=20,tt=2144,et=8;class v{constructor(){this.address=new Uint8Array(x),this.amount=BigInt(0)}bytes(){const t=new Uint8Array(x+et);return t.set(this.address),t.set(this.getAmountBytes(),x),t}getTag(){return this.address.slice(0,S)}setTag(t){this.address.set(t.slice(0,S),0)}getAddress(){return this.address.slice(S)}setAddress(t){this.address.set(t.slice(0,x-S),S)}setAmountBytes(t){this.amount=BigInt(new DataView(t.buffer).getBigUint64(0,!0))}getAmount(){return this.amount}getAmountBytes(){const t=new ArrayBuffer(et);return new DataView(t).setBigUint64(0,this.amount,!0),new Uint8Array(t)}static wotsAddressFromBytes(t){const e=new v;if(t.length===tt){const s=this.addrFromWots(t);s&&(e.setTag(s.slice(0,S)),e.setAddress(s.slice(S)))}else t.length===x?(e.setTag(t.slice(0,S)),e.setAddress(t.slice(S))):t.length===x+et&&(e.setTag(t.slice(0,S)),e.setAddress(t.slice(S,x)),e.setAmountBytes(t.slice(x)));return e}static wotsAddressFromHex(t){const e=Buffer.from(t,"hex");return e.length!==x?new v:this.wotsAddressFromBytes(e)}static addrFromImplicit(t){const e=new Uint8Array(x);return e.set(t.slice(0,S),0),e.set(t.slice(0,x-S),S),e}static addrHashGenerate(t){const e=T.hashWith("sha3-512",t);return T.hashWith("ripemd160",e)}static addrFromWots(t){if(t.length!==tt)return null;const e=this.addrHashGenerate(t.slice(0,tt));return this.addrFromImplicit(e)}}let re=class It{constructor({name:t=null,wots:e=null,addrTag:s=null,secret:r=null}){var i;if(r&&r.length!==32)throw new Error("Invalid secret length");if(s&&s.length!==20)throw new Error("Invalid address tag");this.name=t,this.wots=e,this.addrTag=s,this.secret=r,this.wotsAddrHex=this.wots?l.bytesToHex(this.wots):null,this.addrTagHex=this.addrTag?l.bytesToHex(this.addrTag):null,this.mochimoAddr=this.wots?v.wotsAddressFromBytes(this.wots):null,(i=this.mochimoAddr)==null||i.setTag(this.addrTag)}getName(){return this.name}getWots(){return this.wots?new Uint8Array(this.wots):null}getWotsHex(){return this.wotsAddrHex}getWotsPk(){return this.wots?new Uint8Array(this.wots.slice(0,c.WOTSSIGBYTES)):null}getWotsPubSeed(){return this.wots?this.wots.subarray(c.WOTSSIGBYTES,c.WOTSSIGBYTES+32):null}getWotsAdrs(){return this.wots?this.wots.subarray(c.WOTSSIGBYTES+32,c.WOTSSIGBYTES+64):null}getWotsTag(){return this.wots?this.wots.subarray(c.WOTSSIGBYTES+64-12,c.WOTSSIGBYTES+64):null}getAddress(){return this.mochimoAddr?this.mochimoAddr.getAddress():null}getAddrTag(){return this.addrTag?new Uint8Array(this.addrTag):null}getAddrTagHex(){return this.addrTagHex}getAddrHash(){return this.mochimoAddr?this.mochimoAddr.getAddress():null}getSecret(){return this.secret?new Uint8Array(this.secret):null}hasSecret(){return this.secret!==null}sign(t){const e=this.secret,s=this.wots;if(!e||!s)throw new Error("Cannot sign without secret key or address");if(e.length!==32)throw new Error("Invalid sourceSeed length, expected 32, got "+e.length);if(s.length!==2208)throw new Error("Invalid sourceWots length, expected 2208, got "+s.length);s.subarray(0,c.WOTSSIGBYTES);const r=s.subarray(c.WOTSSIGBYTES,c.WOTSSIGBYTES+32),i=s.subarray(c.WOTSSIGBYTES+32,c.WOTSSIGBYTES+64),h=new Uint8Array(c.WOTSSIGBYTES);return c.wots_sign(h,t,e,r,0,i),h}verify(t,e){if(!this.wots)throw new Error("Cannot verify without public key (address)");const s=this.wots,r=s.subarray(0,c.WOTSSIGBYTES),i=s.subarray(c.WOTSSIGBYTES,c.WOTSSIGBYTES+32),h=s.subarray(c.WOTSSIGBYTES+32,c.WOTSSIGBYTES+64),o=c.wots_pk_from_sig(e,t,i,h);return l.areEqual(o,r)}static componentsGenerator(t){const e=Buffer.from(t).toString("ascii"),s=T.hash(Buffer.from(e+"seed","ascii")),r=T.hash(Buffer.from(e+"publ","ascii")),i=T.hash(Buffer.from(e+"addr","ascii"));return{private_seed:s,public_seed:r,addr_seed:i}}clear(){this.secret&&l.clear(this.secret),this.wots&&l.clear(this.wots),this.addrTag&&l.clear(this.addrTag),this.addrTagHex&&(this.addrTagHex=null),this.wotsAddrHex&&(this.wotsAddrHex=null),this.mochimoAddr&&(this.mochimoAddr=null)}toString(){let t="Empty address";return this.wotsAddrHex?t=`${this.wotsAddrHex.substring(0,32)}...${this.wotsAddrHex.substring(this.wotsAddrHex.length-24)}`:this.addrTagHex&&(t=`tag-${this.addrTagHex}`),t}static create(t,e,s,r){if(e.length!==32)throw new Error("Invalid secret length");if(s.length!==20)throw new Error("Invalid tag");let i=e,h=null;const o=Buffer.from("420000000e00000001000000","hex");return r?h=c.generateRandomAddress(o,e,r):({private_seed:i}=this.componentsGenerator(e),h=c.generateAddress(o,e,this.componentsGenerator)),new It({name:t,wots:h,addrTag:s,secret:i})}toJSON(){return{name:this.name,wots:this.wots,addrTag:this.addrTag,secret:this.secret,addrTagHex:this.addrTagHex,wotsAddrHex:this.wotsAddrHex}}};var st=(n=>(n[n.Null=0]="Null",n[n.Hello=1]="Hello",n[n.HelloAck=2]="HelloAck",n[n.Transaction=3]="Transaction",n[n.Found=4]="Found",n[n.GetBlock=5]="GetBlock",n[n.GetIPList=6]="GetIPList",n[n.SendBL=7]="SendBL",n[n.SendIP=8]="SendIP",n[n.Busy=9]="Busy",n[n.Nack=10]="Nack",n[n.GetTFile=11]="GetTFile",n[n.Balance=12]="Balance",n[n.SendBal=13]="SendBal",n[n.Resolve=14]="Resolve",n[n.GetCBlock=15]="GetCBlock",n[n.MBlock=16]="MBlock",n[n.Hash=17]="Hash",n[n.TF=18]="TF",n[n.Identify=19]="Identify",n))(st||{});const ne=[0,4129,8258,12387,16516,20645,24774,28903,33032,37161,41290,45419,49548,53677,57806,61935,4657,528,12915,8786,21173,17044,29431,25302,37689,33560,45947,41818,54205,50076,62463,58334,9314,13379,1056,5121,25830,29895,17572,21637,42346,46411,34088,38153,58862,62927,50604,54669,13907,9842,5649,1584,30423,26358,22165,18100,46939,42874,38681,34616,63455,59390,55197,51132,18628,22757,26758,30887,2112,6241,10242,14371,51660,55789,59790,63919,35144,39273,43274,47403,23285,19156,31415,27286,6769,2640,14899,10770,56317,52188,64447,60318,39801,35672,47931,43802,27814,31879,19684,23749,11298,15363,3168,7233,60846,64911,52716,56781,44330,48395,36200,40265,32407,28342,24277,20212,15891,11826,7761,3696,65439,61374,57309,53244,48923,44858,40793,36728,37256,33193,45514,41451,53516,49453,61774,57711,4224,161,12482,8419,20484,16421,28742,24679,33721,37784,41979,46042,49981,54044,58239,62302,689,4752,8947,13010,16949,21012,25207,29270,46570,42443,38312,34185,62830,58703,54572,50445,13538,9411,5280,1153,29798,25671,21540,17413,42971,47098,34713,38840,59231,63358,50973,55100,9939,14066,1681,5808,26199,30326,17941,22068,55628,51565,63758,59695,39368,35305,47498,43435,22596,18533,30726,26663,6336,2273,14466,10403,52093,56156,60223,64286,35833,39896,43963,48026,19061,23124,27191,31254,2801,6864,10931,14994,64814,60687,56684,52557,48554,44427,40424,36297,31782,27655,23652,19525,15522,11395,7392,3265,61215,65342,53085,57212,44955,49082,36825,40952,28183,32310,20053,24180,11923,16050,3793,7920];function ie(n,t,e){if(t+e>n.length)throw new Error("Offset + length exceeds array bounds");let s=0;for(let r=t;r<t+e;r++){const i=n[r]&255,h=(s>>>8^i)&255;s=(s<<8^ne[h])&65535}return s}const V={LENGTH:8920,TRANSACTION_BUFFER_LENGTH_OFFSET:122,TRANSACTION_BUFFER_LENGTH_LENGTH:2,TRANSACTION_BUFFER_OFFSET:124,TRANSACTION_BUFFER_LENGTH:8792,ADD_TO_PEER_LIST_TRANSACTION_BUFFER_LENGTH:0,DO_NOT_ADD_TO_PEER_LIST_TRANSACTION_BUFFER_LENGTH:1};var St=(n=>(n[n.Push=7]="Push",n[n.Wallet=6]="Wallet",n[n.Sanctuary=5]="Sanctuary",n[n.MFee=4]="MFee",n[n.Logging=3]="Logging",n))(St||{});class O{constructor(){this.version=4,this.flags=new Array(8).fill(!1),this.network=1337,this.id1=0,this.id2=0,this.operation=st.Transaction,this.cblock=0n,this.blocknum=0n,this.cblockhash=new Uint8Array(32),this.pblockhash=new Uint8Array(32),this.weight=new Uint8Array(32),this.transactionBufferLength=1,this.sourceAddress=new Uint8Array(2208),this.destinationAddress=new Uint8Array(2208),this.changeAddress=new Uint8Array(2208),this.totalSend=new Uint8Array(8),this.totalChange=new Uint8Array(8),this.fee=new Uint8Array(8),this.signature=new Uint8Array(2144),this.trailer=43981}serialize(){if(!this.operation)throw new Error("Operation not set");const t=I.allocate(V.LENGTH);t.order(p.LITTLE_ENDIAN),t.put(this.version);const e=this.flags.map(r=>r?"1":"0").join("");t.put(parseInt(e,2)),t.put(l.numberToLittleEndian(this.network,2)),t.put(l.numberToLittleEndian(this.id1,2)),t.put(l.numberToLittleEndian(this.id2,2)),t.put(l.numberToLittleEndian(this.operation,2)),t.put(l.numberToLittleEndian(Number(this.cblock),8)),t.put(l.numberToLittleEndian(Number(this.blocknum),8)),t.put(this.cblockhash),t.put(this.pblockhash),t.put(this.weight),t.put(l.numberToLittleEndian(this.transactionBufferLength,2)),t.put(this.sourceAddress),t.put(this.destinationAddress),t.put(this.changeAddress),t.put(this.totalSend),t.put(this.totalChange),t.put(this.fee),t.put(this.signature);const s=t.array();return this.crc=ie(s,0,8916),t.put(l.numberToLittleEndian(this.crc,2)),t.put(l.numberToLittleEndian(this.trailer,2)),t.array()}getNetwork(){return this.network}getTrailer(){return this.trailer}getId1(){return this.id1}setId1(t){return this.id1=t,this}getId2(){return this.id2}setId2(t){return this.id2=t,this}getOperation(){return this.operation}setOperation(t){return this.operation=t,this}getCurrentBlockHeight(){return this.cblock}setCurrentBlockHeight(t){return this.cblock=t,this}setCurrentBlockHash(t){if(t.length!==32)throw new Error("Invalid hash length");return this.cblockhash=new Uint8Array(t),this}setPreviousBlockHash(t){if(t.length!==32)throw new Error("Invalid hash length");return this.pblockhash=new Uint8Array(t),this}getBlocknum(){return this.blocknum}setBlocknum(t){return this.blocknum=t,this}getWeight(){return new Uint8Array(this.weight)}setWeight(t){const e=l.fit(t.toString(),32);return this.weight=l.bytesToLittleEndian(e),this}setWeightBytes(t){if(t.length!==32)throw new Error("Invalid weight length");return this.weight=l.bytesToLittleEndian(l.fit(t,32)),this}getCRC(){return this.crc??0}getSourceAddress(){return new Uint8Array(this.sourceAddress)}setSourceAddress(t){if(t.length!==2208)throw new Error("Invalid address length");return this.sourceAddress=new Uint8Array(t),this}getDestinationAddress(){return new Uint8Array(this.destinationAddress)}setDestinationAddress(t){if(t.length!==2208)throw new Error("Invalid address length");return this.destinationAddress=new Uint8Array(t),this}getChangeAddress(){return new Uint8Array(this.changeAddress)}setChangeAddress(t){if(t.length!==2208)throw new Error("Invalid address length");return this.changeAddress=new Uint8Array(t),this}getTotalSend(){return new Uint8Array(this.totalSend)}setTotalSend(t){if(t.length!==8)throw new Error("Invalid amount length");return this.totalSend=new Uint8Array(t),this}setTotalSendBigInt(t){return this.totalSend=l.numberToLittleEndian(Number(t),8),this}getTotalChange(){return new Uint8Array(this.totalChange)}setTotalChange(t){if(t.length!==8)throw new Error("Invalid amount length");return this.totalChange=new Uint8Array(t),this}setTotalChangeBigInt(t){return this.totalChange=l.numberToLittleEndian(Number(t),8),this}getFee(){return new Uint8Array(this.fee)}setFee(t){if(t.length!==8)throw new Error("Invalid amount length");return this.fee=new Uint8Array(t),this}setFeeBigInt(t){return this.fee=l.numberToLittleEndian(Number(t),8),this}getSignature(){return new Uint8Array(this.signature)}setSignature(t){if(t.length!==2144)throw new Error("Invalid signature length");return this.signature=new Uint8Array(t),this}getPblockhash(){return new Uint8Array(this.pblockhash)}getCblockhash(){return new Uint8Array(this.cblockhash)}static parseCapabilities(t,e){for(const s of Object.values(St))typeof s=="number"&&t.flags[s]&&e.add(s);return e}static getRouteAsWeight(t){const e=new Uint8Array(32);let s=0;const r=t.length>8?t.length-8:0;for(let i=r;i<t.length;i++){const h=t[i].trim(),o=h.split(".");if(o.length!==4)throw new Error(`Invalid IP ${h}`);for(const a of o){const d=parseInt(a);if(d<0||d>255)throw new Error(`Invalid byte ${d}`);e[s++]=d}}return e}static parseTxIps(t,e){const s=t.getWeight();for(let r=0;r<s.length;r+=4){let i=0;const h=[];for(let o=0;o<4;o++){const a=s[r+o];if(a===0&&i++,i>=4)break;h.push(a)}if(i>=4)break;e.add(h.join("."))}return e}getTransactionBufferLength(){return this.transactionBufferLength}setTransactionBufferLength(t){return this.transactionBufferLength=t,this}isAddToPeerList(){return this.getTransactionBufferLength()!==1}setAddToPeerList(t){return this.setTransactionBufferLength(t?0:1),this}getVersion(){return this.version}clone(){return O.of(this.serialize())}static of(t){if(t.length<V.LENGTH)throw new Error(`Data length cannot be less than datagram length (${V.LENGTH})`);const e=I.allocate(V.LENGTH);e.order(p.LITTLE_ENDIAN),e.put(t),e.rewind();const s=new O;s.version=e.get_();const i=e.get_().toString(2).padStart(8,"0");s.flags=Array.from(i).map(o=>o!=="0"),s.network=Number(l.readLittleEndianUnsigned(e,2)),s.id1=Number(l.readLittleEndianUnsigned(e,2)),s.id2=Number(l.readLittleEndianUnsigned(e,2));const h=Number(l.readLittleEndianUnsigned(e,2));if(h===0)throw new Error("Invalid operation code 0");return s.operation=h,s.cblock=l.readLittleEndianUnsigned(e,8),s.blocknum=l.readLittleEndianUnsigned(e,8),e.get(s.cblockhash),e.get(s.pblockhash),e.get(s.weight),s.transactionBufferLength=Number(l.readLittleEndianUnsigned(e,2)),e.get(s.sourceAddress),e.get(s.destinationAddress),e.get(s.changeAddress),e.get(s.totalSend),e.get(s.totalChange),e.get(s.fee),e.get(s.signature),s.crc=Number(l.readLittleEndianUnsigned(e,2)),s.trailer=Number(l.readLittleEndianUnsigned(e,2)),s}}const A={LENGTH:8824,ADDRESS_LENGTH:2208,SIGNATURE_LENGTH:2144,ID_LENGTH:32,AMOUNT_LENGTH:8};class E{constructor(t,e,s,r,i,h,o,a){if(t.length!==2208)throw new Error("Invalid source address length");if(e.length!==2208)throw new Error("Invalid destination address length");if(s.length!==2208)throw new Error("Invalid change address length");if(o.length!==2144)throw new Error("Invalid signature length");if(a.length!==32)throw new Error("Invalid id length");this.sourceAddress=new Uint8Array(t),this.destinationAddress=new Uint8Array(e),this.changeAddress=new Uint8Array(s),this.signature=new Uint8Array(o),this.id=new Uint8Array(a),this.sourceAddressHex=l.bytesToHex(this.sourceAddress),this.destinationAddressHex=l.bytesToHex(this.destinationAddress),this.changeAddressHex=l.bytesToHex(this.changeAddress),this.signatureHex=l.bytesToHex(this.signature),this.idHex=l.bytesToHex(this.id),this.totalSend=r,this.totalChange=i,this.fee=h,this.idValue=E.txIdToInteger(this.id)}static txIdToInteger(t){let e=0n;for(let s=0;s<t.length;s++)e=e<<8n|BigInt(t[s]);return e}static txId(t){if(t.length!==2208)throw new Error("Invalid WOTS length");return T.hash(t)}static isValidWOTSSignature(t){const e=T.hash(t.subarray(0,6648)),s=t.subarray(0,2208),r=s.subarray(0,2144),i=s.subarray(2144,2176),h=s.subarray(2176,2208),o=t.subarray(6648,8792),a=c.wots_pk_from_sig(o,e,i,h);if(a.length!==r.length)return!1;for(let d=0;d<r.length;d++)if(a[d]!==r[d])return!1;return!0}static of(t){if(t.length!==A.LENGTH)throw new Error(`Data length must be ${A.LENGTH}`);const e=I.wrap(t);e.order(p.LITTLE_ENDIAN);const s=new Uint8Array(2208);e.get(s);const r=new Uint8Array(2208);e.get(r);const i=new Uint8Array(2208);e.get(i);const h=l.readLittleEndianUnsigned(e,8),o=l.readLittleEndianUnsigned(e,8),a=l.readLittleEndianUnsigned(e,8),d=new Uint8Array(2144);e.get(d);const g=new Uint8Array(32);return e.get(g),new E(s,r,i,h,o,a,d,g)}static bigIntToLEBytes(t,e){const s=new Uint8Array(e);let r=t;for(let i=0;i<e;i++)s[i]=Number(r&0xFFn),r>>=8n;return s}static bytesToBigInt(t){let e=0n;for(let s=t.length-1;s>=0;s--)e=e<<8n|BigInt(t[s]);return e}serialize(){const t=I.allocate(A.LENGTH);return t.order(p.LITTLE_ENDIAN),t.put(this.sourceAddress),t.put(this.destinationAddress),t.put(this.changeAddress),t.put(E.bigIntToLEBytes(this.totalSend,8)),t.put(E.bigIntToLEBytes(this.totalChange,8)),t.put(E.bigIntToLEBytes(this.fee,8)),t.put(this.signature),t.put(this.id),t.array()}static validate(t,e,s){const r=t.serialize();if(r.length!==A.LENGTH)return`Invalid transaction length (expected ${A.LENGTH} but was ${r.length})`;if(l.compareBytes(t.sourceAddress,t.destinationAddress))return"Source address is identical to destination address";if(l.compareBytes(t.sourceAddress,t.changeAddress))return"Source address is identical to change address";if(t.fee<e)return`Invalid transaction fee (min required ${e} but was ${t.fee})`;const i=E.txId(t.sourceAddress);return l.compareBytes(i,t.id)?s&&t.idValue<=s.idValue?`Invalid transaction order (id ${t.idValue} should be after ${s.idValue})`:t.totalSend<0n?"Total send cannot be negative":t.totalChange<0n?"Total change cannot be negative":t.fee<0n?"Fee cannot be negative":E.isValidWOTSSignature(r)?null:"Invalid WOTS signature":`Invalid transaction id (expected ${l.bytesToHex(i)} but was ${t.idHex})`}static sign(t,e,s,r,i,h,o,a){if(i.length!==2208)throw new Error("Invalid source address length");if(o.length!==2208)throw new Error("Invalid destination address length");if(a.length!==2208)throw new Error("Invalid change address length");if(t<=0n)throw new Error("Balance must be positive");if(e<0n)throw new Error("Payment cannot be negative");if(s<0n)throw new Error("Fee cannot be negative");if(r<0n)throw new Error("Change cannot be negative");const d=t-s;if(d<0n)throw new Error("Not enough fund for fee");const g=d-e;if(g<0n)throw new Error("Not enough fund for fee and payment");const u=g-r;if(u<0n)throw new Error("Not enough fund for fee, payment and change");if(u>0n)throw new Error("Source address not fully spent");const w=I.allocate(A.LENGTH);w.order(p.LITTLE_ENDIAN),w.put(i),w.put(o),w.put(a),w.put(E.bigIntToLEBytes(e,A.AMOUNT_LENGTH)),w.put(E.bigIntToLEBytes(r,A.AMOUNT_LENGTH)),w.put(E.bigIntToLEBytes(s,A.AMOUNT_LENGTH));const f=w.array().subarray(0,6648),k=T.hash(f);i.subarray(0,A.SIGNATURE_LENGTH);const G=i.subarray(A.SIGNATURE_LENGTH,A.SIGNATURE_LENGTH+32),rt=i.subarray(A.SIGNATURE_LENGTH+32,A.SIGNATURE_LENGTH+64),C=new Uint8Array(A.SIGNATURE_LENGTH);c.wots_sign(C,k,h,G,0,rt),w.position(6648),w.put(C);const nt=E.txId(i);if(w.put(nt),w.array().length!==A.LENGTH)throw new Error("Transaction length mismatch");const m=new O;return m.setOperation(st.Transaction),m.setSourceAddress(i),m.setDestinationAddress(o),m.setChangeAddress(a),m.setTotalSend(E.bigIntToLEBytes(e,A.AMOUNT_LENGTH)),m.setTotalChange(E.bigIntToLEBytes(r,A.AMOUNT_LENGTH)),m.setFee(E.bigIntToLEBytes(s,A.AMOUNT_LENGTH)),m.setSignature(C),{datagram:m.serialize(),tx:w.array()}}}class ${constructor({name:t=null,address:e=null,tag:s=null,secret:r=null}){this.name=t,this.address=e,this.tag=s,this.secret=r,this.addressHex=this.address?l.bytesToHex(this.address):null,this.tagHex=this.tag?l.bytesToHex(this.tag):null,this.v3address=this.address?v.wotsAddressFromBytes(this.address):null}getName(){return this.name}getAddress(){return this.address?new Uint8Array(this.address):null}getAddr(){return this.address?new Uint8Array(this.address.slice(c.WOTSSIGBYTES,c.WOTSSIGBYTES+32)):null}getPublSeed(){return this.address?new Uint8Array(this.address.slice(c.WOTSSIGBYTES,c.WOTSSIGBYTES+32)):null}getAddressHex(){return this.addressHex}getTag(){return this.tag?new Uint8Array(this.tag):null}getTagHex(){return this.tagHex}getSecret(){return this.secret?new Uint8Array(this.secret):null}hasSecret(){return this.secret!==null}sign(t){const e=this.secret,s=this.address;if(!e||!s)throw new Error("Cannot sign without secret key or address");if(e.length!==32)throw new Error("Invalid sourceSeed length, expected 32, got "+e.length);if(s.length!==2208)throw new Error("Invalid sourceWots length, expected 2208, got "+s.length);s.subarray(0,c.WOTSSIGBYTES);const r=s.subarray(c.WOTSSIGBYTES,c.WOTSSIGBYTES+32),i=s.subarray(c.WOTSSIGBYTES+32,c.WOTSSIGBYTES+64),h=new Uint8Array(c.WOTSSIGBYTES);return c.wots_sign(h,t,e,r,0,i),h}verify(t,e){if(!this.address)throw new Error("Cannot verify without public key (address)");const s=this.address,r=s.subarray(0,c.WOTSSIGBYTES),i=s.subarray(c.WOTSSIGBYTES,c.WOTSSIGBYTES+32),h=s.subarray(c.WOTSSIGBYTES+32,c.WOTSSIGBYTES+64),o=c.wots_pk_from_sig(e,t,i,h);return l.areEqual(o,r)}static componentsGenerator(t){const e=Buffer.from(t).toString("ascii"),s=T.hash(Buffer.from(e+"seed","ascii")),r=T.hash(Buffer.from(e+"publ","ascii")),i=T.hash(Buffer.from(e+"addr","ascii"));return{private_seed:s,public_seed:r,addr_seed:i}}clear(){this.secret&&l.clear(this.secret),this.address&&l.clear(this.address),this.tag&&l.clear(this.tag),this.tagHex&&(this.tagHex=null),this.addressHex&&(this.addressHex=null)}toString(){let t="Empty address";return this.addressHex?t=`${this.addressHex.substring(0,32)}...${this.addressHex.substring(this.addressHex.length-24)}`:this.tagHex&&(t=`tag-${this.tagHex}`),t}toJSON(){return{name:this.name,address:this.address,tag:this.tag,secret:this.secret,tagHex:this.tagHex,addressHex:this.addressHex}}static create(t,e,s){if(e.length!==32)throw new Error("Invalid secret length");if(s!==null&&s.length!==12)throw new Error("Invalid tag");const{private_seed:r}=this.componentsGenerator(e),i=c.generateAddress(s,e,this.componentsGenerator);return new $({name:t,address:i,tag:s,secret:r})}static createV3(t,e,s){const{private_seed:r}=this.componentsGenerator(e),i=c.generateAddress(s,e,this.componentsGenerator);return new $({name:t,address:i,tag:s,secret:r})}}y.ByteBuffer=I,y.ByteOrder=p,y.Datagram=O,y.MochimoHasher=T,y.Tag=F,y.Transaction=E,y.WOTS=c,y.WOTSWallet=re,y.WOTSWalletV2=$,y.WotsAddress=v,Object.defineProperty(y,Symbol.toStringTag,{value:"Module"})});
