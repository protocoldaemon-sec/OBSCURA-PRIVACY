/**
 * Arcium Callback Type Definitions
 * 
 * TypeScript equivalents of Arcium's auto-generated Rust callback types.
 * These mirror the structs generated by the #[instruction] macro.
 * 
 * Key concepts:
 * - SharedEncryptedStruct<LEN>: Data both client and MXE can decrypt
 * - MXEEncryptedStruct<LEN>: Data only MXE can decrypt
 * - LEN = count of encrypted scalar values
 * 
 * @see https://docs.arcium.com/developers/callback-type-generation
 */

// ============ Core Encrypted Struct Types ============

/**
 * SharedEncryptedStruct<LEN> - Encrypted data decryptable by client and MXE
 * 
 * Rust equivalent:
 * ```rust
 * pub struct SharedEncryptedStruct<const LEN: usize> {
 *   pub encryption_key: [u8; 32],
 *   pub nonce: u128,
 *   pub ciphertexts: [[u8; 32]; LEN],
 * }
 * ```
 * 
 * Use when: Returning results the user must be able to decrypt
 */
export interface SharedEncryptedStruct {
  /** The shared x25519 public key for key exchange */
  encryptionKey: Uint8Array; // [u8; 32]
  /** Random nonce for security */
  nonce: bigint; // u128
  /** Array of encrypted 32-byte values */
  ciphertexts: Uint8Array[]; // [[u8; 32]; LEN]
}

/**
 * MXEEncryptedStruct<LEN> - Encrypted data only MXE can decrypt
 * 
 * Rust equivalent:
 * ```rust
 * pub struct MXEEncryptedStruct<const LEN: usize> {
 *   pub nonce: u128,
 *   pub ciphertexts: [[u8; 32]; LEN],
 * }
 * ```
 * 
 * Use when: Storing internal state users shouldn't access
 */
export interface MXEEncryptedStruct {
  /** Random nonce for security */
  nonce: bigint; // u128
  /** Array of encrypted 32-byte values */
  ciphertexts: Uint8Array[]; // [[u8; 32]; LEN]
}

/**
 * EncDataStruct<LEN> - Raw encrypted data without metadata
 * 
 * Less commonly used, for special cases where only ciphertext is needed.
 */
export interface EncDataStruct {
  /** Array of encrypted 32-byte values */
  ciphertexts: Uint8Array[]; // [[u8; 32]; LEN]
}

// ============ Computation Output Types ============

/**
 * Signed computation outputs wrapper
 * 
 * Rust equivalent: SignedComputationOutputs<T>
 */
export interface SignedComputationOutputs<T> {
  /** The typed output data */
  output: T;
  /** Cluster signature for verification */
  clusterSignature: Uint8Array;
  /** Computation account pubkey */
  computationAccount: string;
}

/**
 * Computation output result (success or aborted)
 */
export type ComputationOutputResult<T> = 
  | { status: 'success'; data: T }
  | { status: 'aborted'; error: string };

// ============ Output Struct Builders ============

/**
 * Create a SharedEncryptedStruct from raw bytes
 * 
 * Layout: [encryption_key: 32][nonce: 16][ciphertexts: 32 * LEN]
 */
export function parseSharedEncryptedStruct(
  data: Uint8Array,
  len: number
): SharedEncryptedStruct {
  const expectedSize = 32 + 16 + (32 * len);
  if (data.length < expectedSize) {
    throw new Error(`Insufficient data: expected ${expectedSize} bytes, got ${data.length}`);
  }

  const encryptionKey = data.slice(0, 32);
  const nonceBytes = data.slice(32, 48);
  const nonce = bytesToU128(nonceBytes);
  
  const ciphertexts: Uint8Array[] = [];
  for (let i = 0; i < len; i++) {
    const start = 48 + (i * 32);
    ciphertexts.push(data.slice(start, start + 32));
  }

  return { encryptionKey, nonce, ciphertexts };
}

/**
 * Create an MXEEncryptedStruct from raw bytes
 * 
 * Layout: [nonce: 16][ciphertexts: 32 * LEN]
 */
export function parseMXEEncryptedStruct(
  data: Uint8Array,
  len: number
): MXEEncryptedStruct {
  const expectedSize = 16 + (32 * len);
  if (data.length < expectedSize) {
    throw new Error(`Insufficient data: expected ${expectedSize} bytes, got ${data.length}`);
  }

  const nonceBytes = data.slice(0, 16);
  const nonce = bytesToU128(nonceBytes);
  
  const ciphertexts: Uint8Array[] = [];
  for (let i = 0; i < len; i++) {
    const start = 16 + (i * 32);
    ciphertexts.push(data.slice(start, start + 32));
  }

  return { nonce, ciphertexts };
}

/**
 * Serialize SharedEncryptedStruct to bytes
 */
export function serializeSharedEncryptedStruct(
  struct: SharedEncryptedStruct
): Uint8Array {
  const len = struct.ciphertexts.length;
  const result = new Uint8Array(32 + 16 + (32 * len));
  
  result.set(struct.encryptionKey, 0);
  result.set(u128ToBytes(struct.nonce), 32);
  
  for (let i = 0; i < len; i++) {
    result.set(struct.ciphertexts[i], 48 + (i * 32));
  }
  
  return result;
}

/**
 * Serialize MXEEncryptedStruct to bytes
 */
export function serializeMXEEncryptedStruct(
  struct: MXEEncryptedStruct
): Uint8Array {
  const len = struct.ciphertexts.length;
  const result = new Uint8Array(16 + (32 * len));
  
  result.set(u128ToBytes(struct.nonce), 0);
  
  for (let i = 0; i < len; i++) {
    result.set(struct.ciphertexts[i], 16 + (i * 32));
  }
  
  return result;
}

// ============ LEN Calculation Helpers ============

/**
 * Calculate LEN for a type based on its scalar count
 * 
 * Examples:
 * - u32 → 1
 * - (u32, bool) → 2
 * - [u32; 5] → 5
 * - struct { id: u32, balance: u64, active: bool } → 3
 */
export type ScalarType = 
  | 'u8' | 'u16' | 'u32' | 'u64' | 'u128'
  | 'i8' | 'i16' | 'i32' | 'i64' | 'i128'
  | 'bool' | 'f32' | 'f64';

export interface TypeSchema {
  type: 'scalar' | 'array' | 'tuple' | 'struct';
  scalarType?: ScalarType;
  arrayLength?: number;
  elementType?: TypeSchema;
  tupleTypes?: TypeSchema[];
  structFields?: { name: string; type: TypeSchema }[];
}

/**
 * Calculate the LEN (scalar count) for a type schema
 */
export function calculateLen(schema: TypeSchema): number {
  switch (schema.type) {
    case 'scalar':
      return 1;
    case 'array':
      return (schema.arrayLength ?? 0) * calculateLen(schema.elementType!);
    case 'tuple':
      return (schema.tupleTypes ?? []).reduce((sum, t) => sum + calculateLen(t), 0);
    case 'struct':
      return (schema.structFields ?? []).reduce((sum, f) => sum + calculateLen(f.type), 0);
    default:
      return 0;
  }
}

// ============ Obscura-specific Output Types ============

/**
 * Output type for verify_intent_eligibility instruction
 * 
 * Rust: `fn verify_intent_eligibility(...) -> Enc<Shared, bool>`
 * Generated: `VerifyIntentEligibilityOutput { field_0: SharedEncryptedStruct<1> }`
 */
export interface VerifyIntentEligibilityOutput {
  field_0: SharedEncryptedStruct; // bool result (LEN=1)
}

/**
 * Output type for compare_quotes instruction
 * 
 * Rust: `fn compare_quotes(...) -> (Enc<Shared, u8>, Enc<Mxe, [u64; 10]>)`
 * Generated: nested struct with winner_index and sorted_quotes
 */
export interface CompareQuotesOutput {
  field_0: CompareQuotesOutputStruct0;
}

export interface CompareQuotesOutputStruct0 {
  field_0: SharedEncryptedStruct; // winner_index (LEN=1)
  field_1: MXEEncryptedStruct;    // sorted_quotes (LEN=10)
}

/**
 * Output type for optimize_batch instruction
 * 
 * Rust: `fn optimize_batch(...) -> (Enc<Shared, [u8; 50]>, Enc<Shared, u64>)`
 */
export interface OptimizeBatchOutput {
  field_0: OptimizeBatchOutputStruct0;
}

export interface OptimizeBatchOutputStruct0 {
  field_0: SharedEncryptedStruct; // ordering indices (LEN=50)
  field_1: SharedEncryptedStruct; // gas_savings (LEN=1)
}

/**
 * Output type for solver_auction instruction
 * 
 * Rust: `fn solver_auction(...) -> (Enc<Shared, u8>, Enc<Shared, u64>)`
 */
export interface SolverAuctionOutput {
  field_0: SolverAuctionOutputStruct0;
}

export interface SolverAuctionOutputStruct0 {
  field_0: SharedEncryptedStruct; // winner_index (LEN=1)
  field_1: SharedEncryptedStruct; // winning_amount (LEN=1)
}

/**
 * Output type for compliance_disclosure instruction
 * 
 * Rust: `fn compliance_disclosure(...) -> (Enc<Shared, [u8; 32]>, Enc<Shared, [u8; 32]>, Enc<Shared, u64>)`
 */
export interface ComplianceDisclosureOutput {
  field_0: ComplianceDisclosureOutputStruct0;
}

export interface ComplianceDisclosureOutputStruct0 {
  field_0: SharedEncryptedStruct; // sealed_sender (LEN=1, 32-byte value)
  field_1: SharedEncryptedStruct; // sealed_recipient (LEN=1, 32-byte value)
  field_2: SharedEncryptedStruct; // sealed_amount (LEN=1)
}

// ============ Utility Functions ============

/**
 * Convert 16 bytes (little-endian) to u128
 */
function bytesToU128(bytes: Uint8Array): bigint {
  let value = 0n;
  for (let i = 15; i >= 0; i--) {
    value = (value << 8n) | BigInt(bytes[i]);
  }
  return value;
}

/**
 * Convert u128 to 16 bytes (little-endian)
 */
function u128ToBytes(value: bigint): Uint8Array {
  const bytes = new Uint8Array(16);
  let remaining = value;
  for (let i = 0; i < 16; i++) {
    bytes[i] = Number(remaining & 0xffn);
    remaining >>= 8n;
  }
  return bytes;
}

/**
 * Extract nonce as little-endian bytes (for emitting in events)
 */
export function nonceToLeBytes(nonce: bigint): Uint8Array {
  return u128ToBytes(nonce);
}

/**
 * Verify computation output signature
 * 
 * In production, this would verify the cluster's ed25519 signature
 * over the computation output data.
 */
export function verifyOutputSignature(
  _output: SignedComputationOutputs<unknown>,
  _clusterPubKey: Uint8Array
): boolean {
  // TODO: Implement actual signature verification
  // This would use the cluster's ed25519 verifying key
  return true;
}
